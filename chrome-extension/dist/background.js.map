{"version":3,"file":"background.js","mappings":"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","sources":["webpack://macro-engine-activity-tracker/./src/background.ts"],"sourcesContent":["import { UserEvent, Message } from './types';\n\n// ==================== CONFIGURATION ====================\n\n// API Configuration\nconst API_CONFIG = {\n  endpoint: 'http://localhost:3000/api/events',\n  timeout: 10000,\n  maxRetries: 3,\n  retryDelay: 1000,\n} as const;\n\n// Performance Configuration  \nconst PERFORMANCE_CONFIG = {\n  maxBatchSize: 50, // MAX 50 events per batch to prevent 413 errors\n  maxBatchSizeBytes: 100 * 1024, // 100KB max payload\n  batchIntervalMinutes: 2, // Send every 2 minutes (reduced from 5)\n  maxStoredEvents: 1000, // Prevent infinite accumulation\n  storageCleanupThreshold: 0.7, // Clean up at 70%\n  keepaliveIntervalMinutes: 1, // Reduced service worker overhead\n} as const;\n\n// Storage Keys\nconst STORAGE_KEYS = {\n  events: 'maqroUserEvents',\n  stats: 'maqroStats',\n} as const;\n\n// Alarm Names\nconst ALARM_NAMES = {\n  batchSend: 'maqroBatchSendAlarm',\n  keepalive: 'maqroKeepaliveAlarm',\n} as const;\n\n// Feature Flags\nconst FEATURE_FLAGS = {\n  enablePerformanceLogging: false, // Reduce console spam\n  enableRetryLogic: true,\n  enableChunkedSending: true,\n} as const;\n\n// ==================== STATE MANAGEMENT ====================\n\ninterface ExtensionState {\n  isCollecting: boolean;\n  userManuallyPaused: boolean;\n  isSendingBatch: boolean;\n  lastSendAttempt: number;\n  sendFailureCount: number;\n  totalEventsSent: number;\n  totalEventsDropped: number;\n}\n\nconst state: ExtensionState = {\n  isCollecting: true,\n  userManuallyPaused: false,\n  isSendingBatch: false,\n  lastSendAttempt: 0,\n  sendFailureCount: 0,\n  totalEventsSent: 0,\n  totalEventsDropped: 0,\n};\n\n// ==================== UTILITY FUNCTIONS ====================\n\n/**\n * Enhanced logging with performance mode toggle\n */\nfunction log(level: 'info' | 'warn' | 'error', message: string, ...args: any[]) {\n  const prefix = 'Maqro:';\n  if (level === 'error' || FEATURE_FLAGS.enablePerformanceLogging) {\n    console[level](prefix, message, ...args);\n  }\n}\n\n/**\n * Calculate size of events array in bytes\n */\nfunction calculateEventsSizeBytes(events: UserEvent[]): number {\n  return new TextEncoder().encode(JSON.stringify(events)).length;\n}\n\n/**\n * Split events into chunks that respect size limits\n */\nfunction chunkEvents(events: UserEvent[]): UserEvent[][] {\n  const chunks: UserEvent[][] = [];\n  let currentChunk: UserEvent[] = [];\n  let currentSize = 0;\n  \n  for (const event of events) {\n    const eventSize = calculateEventsSizeBytes([event]);\n    \n    // If adding this event would exceed limits, start new chunk\n    if (currentChunk.length >= PERFORMANCE_CONFIG.maxBatchSize || \n        currentSize + eventSize > PERFORMANCE_CONFIG.maxBatchSizeBytes) {\n      if (currentChunk.length > 0) {\n        chunks.push(currentChunk);\n        currentChunk = [];\n        currentSize = 0;\n      }\n    }\n    \n    currentChunk.push(event);\n    currentSize += eventSize;\n  }\n  \n  if (currentChunk.length > 0) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks;\n}\n\n// ==================== CORE FUNCTIONS ====================\n\n/**\n * Enhanced batch sending with chunking and retry logic\n */\nasync function sendBatchToServer(): Promise<void> {\n  if (state.isSendingBatch) {\n    log('info', 'Batch send already in progress. Skipping.');\n    return;\n  }\n  \n  state.isSendingBatch = true;\n  state.lastSendAttempt = Date.now();\n  \n  try {\n    // Get events from storage\n    const result = await chrome.storage.local.get(STORAGE_KEYS.events);\n    const allEvents: UserEvent[] = result[STORAGE_KEYS.events] || [];\n    \n    if (allEvents.length === 0) {\n      log('info', 'No events to send.');\n      return;\n    }\n    \n    // Implement chunking to prevent 413 errors\n    const chunks = chunkEvents(allEvents);\n    log('info', `Sending ${allEvents.length} events in ${chunks.length} chunks`);\n    \n    let successfulChunks = 0;\n    let failedChunks = 0;\n    \n    // Send each chunk with retry logic\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const success = await sendChunkWithRetry(chunk, i + 1, chunks.length);\n      \n      if (success) {\n        successfulChunks++;\n        state.totalEventsSent += chunk.length;\n      } else {\n        failedChunks++;\n        state.totalEventsDropped += chunk.length;\n      }\n    }\n    \n    // Only clear storage if all chunks sent successfully\n    if (failedChunks === 0) {\n      await chrome.storage.local.remove(STORAGE_KEYS.events);\n      log('info', `All ${successfulChunks} chunks sent successfully. Storage cleared.`);\n      state.sendFailureCount = 0;\n    } else {\n      log('error', `${failedChunks}/${chunks.length} chunks failed. Keeping events in storage.`);\n      state.sendFailureCount++;\n    }\n    \n  } catch (error: any) {\n    log('error', 'Error in batch send process:', error);\n    state.sendFailureCount++;\n  } finally {\n    state.isSendingBatch = false;\n  }\n}\n\n/**\n * Send a single chunk with retry logic\n */\nasync function sendChunkWithRetry(events: UserEvent[], chunkNum: number, totalChunks: number): Promise<boolean> {\n  let retryCount = 0;\n  \n  while (retryCount < API_CONFIG.maxRetries) {\n    try {\n      const payload = JSON.stringify({ events });\n      \n      log('info', `Sending chunk ${chunkNum}/${totalChunks} (${events.length} events, ${payload.length} bytes)`);\n      \n      const response = await fetch(API_CONFIG.endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: payload,\n        signal: AbortSignal.timeout(API_CONFIG.timeout),\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n      }\n      \n      log('info', `Chunk ${chunkNum}/${totalChunks} sent successfully`);\n      return true;\n      \n    } catch (error: any) {\n      retryCount++;\n      \n      if (error.name === 'AbortError') {\n        log('error', `Chunk ${chunkNum} timeout (attempt ${retryCount})`);\n      } else if (error.message.includes('413')) {\n        log('error', `Chunk ${chunkNum} too large (413 error). This chunk will be dropped.`);\n        return false; // Don't retry 413 errors\n      } else {\n        log('error', `Chunk ${chunkNum} failed (attempt ${retryCount}):`, error.message);\n      }\n      \n      if (retryCount < API_CONFIG.maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, API_CONFIG.retryDelay * retryCount));\n      }\n    }\n  }\n  \n  log('error', `Chunk ${chunkNum} failed after ${API_CONFIG.maxRetries} attempts`);\n  return false;\n}\n\n/**\n * Enhanced event storage with size management\n */\nasync function handleUserEvent(event: UserEvent): Promise<void> {\n  if (!state.isCollecting) {\n    return;\n  }\n  \n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.events);\n    let events: UserEvent[] = result[STORAGE_KEYS.events] || [];\n    \n    // Prevent memory bloat - remove oldest events if we hit the limit\n    if (events.length >= PERFORMANCE_CONFIG.maxStoredEvents) {\n      const eventsToRemove = events.length - PERFORMANCE_CONFIG.maxStoredEvents + 1;\n      events = events.slice(eventsToRemove);\n      state.totalEventsDropped += eventsToRemove;\n      log('warn', `Dropped ${eventsToRemove} old events to prevent memory bloat`);\n    }\n    \n    events.push(event);\n    await chrome.storage.local.set({ [STORAGE_KEYS.events]: events });\n    \n    // Check if we need to send early\n    checkStorageAndTriggerSend(events);\n    \n  } catch (error: any) {\n    log('error', 'Error storing event:', error);\n  }\n}\n\n/**\n * Optimized storage check with better thresholds\n */\nfunction checkStorageAndTriggerSend(events: UserEvent[]): void {\n  // Trigger send based on event count or storage usage\n  if (events.length >= PERFORMANCE_CONFIG.maxBatchSize) {\n    log('info', 'Event count threshold reached. Triggering send.');\n    sendBatchToServer();\n    return;\n  }\n  \n  // Check storage size\n  chrome.storage.local.getBytesInUse([STORAGE_KEYS.events], (bytesInUse) => {\n    if (chrome.runtime.lastError) {\n      log('error', 'Error checking storage usage:', chrome.runtime.lastError.message);\n      return;\n    }\n    \n    const storageQuota = chrome.storage.local.QUOTA_BYTES || 5 * 1024 * 1024;\n    const usagePercent = bytesInUse / storageQuota;\n    \n    if (usagePercent > PERFORMANCE_CONFIG.storageCleanupThreshold) {\n      log('info', `Storage threshold reached (${Math.round(usagePercent * 100)}%). Triggering send.`);\n      sendBatchToServer();\n    }\n  });\n}\n\n// ==================== MESSAGE HANDLING ====================\n\nchrome.runtime.onMessage.addListener((message: Message, sender, sendResponse) => {\n  // Reduce logging noise\n  if (FEATURE_FLAGS.enablePerformanceLogging) {\n    log('info', 'Received message', message);\n  }\n  \n  switch (message.type) {\n    case 'USER_EVENT':\n      if (message.event) {\n        handleUserEvent(message.event);\n        sendResponse({ success: true });\n      }\n      break;\n      \n    case 'TOGGLE_COLLECTION':\n      if (typeof message.enabled === 'boolean') {\n        state.userManuallyPaused = !message.enabled;\n        state.isCollecting = message.enabled;\n        \n        log('info', `Collection ${state.isCollecting ? 'enabled' : 'disabled'} by user`);\n        broadcastCollectionStateToAllTabs(state.isCollecting);\n        sendResponse({ success: true, isCollecting: state.isCollecting });\n        \n        // Send pending events when stopping\n        if (!state.isCollecting) {\n          sendBatchToServer();\n        }\n      }\n      return true;\n      \n    case 'GET_OPERATIONAL_STATE':\n      sendResponse({ \n        success: true, \n        isCollecting: state.isCollecting,\n        stats: {\n          totalEventsSent: state.totalEventsSent,\n          totalEventsDropped: state.totalEventsDropped,\n          sendFailureCount: state.sendFailureCount\n        }\n      });\n      return true;\n      \n    case 'HEALTH_CHECK':\n      sendResponse({ success: true, isAlive: true });\n      return true;\n  }\n});\n\n// ==================== TAB MANAGEMENT ====================\n\n/**\n * Optimized tab broadcasting with better error handling\n */\nasync function broadcastCollectionStateToAllTabs(enabled: boolean): Promise<void> {\n  try {\n    const tabs = await chrome.tabs.query({\n      url: ['http://*/*', 'https://*/*'], \n      status: 'complete'\n    });\n    \n    log('info', `Broadcasting collection state (${enabled}) to ${tabs.length} tabs`);\n    \n    const sendPromises = tabs\n      .filter(tab => tab.id)\n      .map(tab => \n        chrome.tabs.sendMessage(tab.id!, { type: 'TOGGLE_COLLECTION', enabled })\n          .catch(() => {\n            // Silently ignore connection errors - they're expected\n          })\n      );\n    \n    await Promise.allSettled(sendPromises);\n    \n  } catch (error: any) {\n    log('error', 'Error broadcasting to tabs:', error);\n  }\n}\n\n// ==================== INITIALIZATION ====================\n\n/**\n * Set up alarms and initial state\n */\nasync function initializeExtension(): Promise<void> {\n  log('info', 'Initializing Maqro extension...');\n  \n  // Create alarms\n  const alarms = [\n    { name: ALARM_NAMES.batchSend, periodInMinutes: PERFORMANCE_CONFIG.batchIntervalMinutes },\n    { name: ALARM_NAMES.keepalive, periodInMinutes: PERFORMANCE_CONFIG.keepaliveIntervalMinutes },\n  ];\n  \n  for (const alarm of alarms) {\n    const existing = await chrome.alarms.get(alarm.name);\n    if (!existing) {\n      await chrome.alarms.create(alarm.name, { periodInMinutes: alarm.periodInMinutes });\n      log('info', `Created ${alarm.name} alarm`);\n    }\n  }\n  \n  // Set initial state\n  state.isCollecting = true;\n  state.userManuallyPaused = false;\n  \n  // Broadcast initial state\n  await broadcastCollectionStateToAllTabs(state.isCollecting);\n  \n  log('info', 'Extension initialization complete');\n}\n\n// ==================== EVENT LISTENERS ====================\n\nchrome.runtime.onInstalled.addListener(initializeExtension);\nchrome.runtime.onStartup.addListener(initializeExtension);\n\n// Alarm handler\nchrome.alarms.onAlarm.addListener((alarm) => {\n  switch (alarm.name) {\n    case ALARM_NAMES.batchSend:\n      log('info', 'Batch send alarm triggered');\n      sendBatchToServer();\n      break;\n      \n    case ALARM_NAMES.keepalive:\n      // Minimal action to keep service worker alive\n      if (FEATURE_FLAGS.enablePerformanceLogging) {\n        log('info', 'Keepalive alarm triggered');\n      }\n      break;\n  }\n});\n\n// Enhanced tab injection with better performance\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && \n      tab.url?.startsWith('http') && \n      !tab.url.includes('chrome://') &&\n      !tab.url.includes('chrome-extension://')) {\n    \n    // Delay injection to ensure page is fully loaded\n    setTimeout(() => {\n      chrome.scripting.executeScript({\n        target: { tabId },\n        files: ['content.js']\n      }).then(() => {\n        log('info', `Content script injected into tab ${tabId}`);\n        \n        // Give content script more time to initialize before sending state\n        setTimeout(() => {\n          chrome.tabs.sendMessage(tabId, { \n            type: 'TOGGLE_COLLECTION', \n            enabled: state.isCollecting \n          }).catch((error) => {\n            // Only log if it's not a common connection error\n            if (!error.message.includes('Could not establish connection') &&\n                !error.message.includes('receiving end does not exist')) {\n              log('warn', `Failed to send initial state to tab ${tabId}: ${error.message}`);\n            }\n          });\n        }, 500); // Increased delay to allow content script to fully initialize\n      }).catch((error) => {\n        // Only log injection errors for pages we should be able to inject into\n        if (!error.message.includes('Cannot access') && \n            !error.message.includes('The extensions gallery cannot be scripted')) {\n          log('warn', `Content script injection failed for tab ${tabId}: ${error.message}`);\n        }\n      });\n    }, 200); // Initial delay to ensure page is stable\n  }\n});\n\n// Extension icon click handler\nchrome.action.onClicked.addListener(() => {\n  const newState = !state.isCollecting;\n  state.userManuallyPaused = !newState;\n  state.isCollecting = newState;\n  \n  log('info', `Extension toggled: ${newState ? 'ON' : 'OFF'}`);\n  broadcastCollectionStateToAllTabs(state.isCollecting);\n  \n  if (!state.isCollecting) {\n    sendBatchToServer();\n  }\n});\n\n// Idle state management (simplified)\nchrome.idle.onStateChanged.addListener((idleState) => {\n  if (!state.userManuallyPaused) {\n    const shouldCollect = idleState === 'active';\n    if (state.isCollecting !== shouldCollect) {\n      state.isCollecting = shouldCollect;\n      broadcastCollectionStateToAllTabs(state.isCollecting);\n    }\n  }\n});\n\n// Window focus management (simplified)\nchrome.windows.onFocusChanged.addListener((windowId) => {\n  if (!state.userManuallyPaused) {\n    const shouldCollect = windowId !== chrome.windows.WINDOW_ID_NONE;\n    if (state.isCollecting !== shouldCollect) {\n      state.isCollecting = shouldCollect;\n      broadcastCollectionStateToAllTabs(state.isCollecting);\n    }\n  }\n});\n  "],"names":["STORAGE_KEYS","ALARM_NAMES","state","isCollecting","userManuallyPaused","isSendingBatch","lastSendAttempt","sendFailureCount","totalEventsSent","totalEventsDropped","log","level","message","args","console","calculateEventsSizeBytes","events","TextEncoder","encode","JSON","stringify","length","async","sendBatchToServer","Date","now","allEvents","chrome","storage","local","get","chunks","currentChunk","currentSize","event","eventSize","push","chunkEvents","successfulChunks","failedChunks","i","chunk","sendChunkWithRetry","remove","error","chunkNum","totalChunks","retryCount","payload","response","fetch","method","headers","body","signal","AbortSignal","timeout","ok","errorText","text","Error","status","name","includes","Promise","resolve","setTimeout","broadcastCollectionStateToAllTabs","enabled","tabs","query","url","sendPromises","filter","tab","id","map","sendMessage","type","catch","allSettled","initializeExtension","alarms","periodInMinutes","alarm","create","runtime","onMessage","addListener","sender","sendResponse","eventsToRemove","slice","set","getBytesInUse","bytesInUse","lastError","usagePercent","QUOTA_BYTES","Math","round","checkStorageAndTriggerSend","handleUserEvent","success","stats","isAlive","onInstalled","onStartup","onAlarm","onUpdated","tabId","changeInfo","startsWith","scripting","executeScript","target","files","then","action","onClicked","newState","idle","onStateChanged","idleState","shouldCollect","windows","onFocusChanged","windowId","WINDOW_ID_NONE"],"sourceRoot":""}