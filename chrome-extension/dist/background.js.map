{"version":3,"file":"background.js","mappings":"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","sources":["webpack://macro-engine-activity-tracker/./node_modules/uuid/dist/esm-browser/native.js","webpack://macro-engine-activity-tracker/./node_modules/uuid/dist/esm-browser/rng.js","webpack://macro-engine-activity-tracker/./node_modules/uuid/dist/esm-browser/stringify.js","webpack://macro-engine-activity-tracker/./node_modules/uuid/dist/esm-browser/v4.js","webpack://macro-engine-activity-tracker/./src/types.ts","webpack://macro-engine-activity-tracker/./src/macro_recommender.ts","webpack://macro-engine-activity-tracker/./src/pattern_integration.ts","webpack://macro-engine-activity-tracker/./src/background.ts"],"sourcesContent":["const randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};","// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\nlet getRandomValues;\nconst rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n\n  return getRandomValues(rnds8);\n}","import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;","import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;","export enum EventType {\n  PAGE_VIEW = 'page_view',\n  SCROLL = 'scroll',\n  CLICK = 'click',\n  FOCUS = 'focus'\n}\n\nexport interface BaseEvent {\n  event_type: EventType;\n  url: string;\n  timestamp: string;\n}\n\nexport interface PageViewEvent extends BaseEvent {\n  event_type: EventType.PAGE_VIEW;\n  title: string;\n  duration: number;\n}\n\nexport interface ScrollEvent extends BaseEvent {\n  event_type: EventType.SCROLL;\n  scrollY: number;\n}\n\nexport interface ClickEvent extends BaseEvent {\n  event_type: EventType.CLICK;\n  selector: string;\n  x: number;\n  y: number;\n}\n\nexport interface FocusEvent extends BaseEvent {\n  event_type: EventType.FOCUS;\n  state: 'focus' | 'blur';\n}\n\nexport type UserEvent = \n  | PageViewEvent \n  | ScrollEvent \n  | ClickEvent \n  | FocusEvent;\n\n// Enhanced message types with better type safety\nexport type Message = \n  | { type: 'USER_EVENT'; event: UserEvent }\n  | { type: 'TOGGLE_COLLECTION'; enabled: boolean }\n  | { type: 'GET_OPERATIONAL_STATE' }\n  | { type: 'HEALTH_CHECK' };\n\n// Statistics interface for monitoring extension performance\nexport interface ExtensionStats {\n  totalEventsSent: number;\n  totalEventsDropped: number;\n  sendFailureCount: number;\n  connectionFailures?: number;\n}\n\n// Response interfaces for better type safety\nexport interface HealthCheckResponse {\n  success: boolean;\n  isAlive: boolean;\n}\n\nexport interface OperationalStateResponse {\n  success: boolean;\n  isCollecting: boolean;\n  stats: ExtensionStats;\n}\n\nexport interface ToggleCollectionResponse {\n  success: boolean;\n  isCollecting: boolean;\n}\n\n// Global window extension for content script guard\ndeclare global {\n  interface Window {\n    maqroContentScriptLoaded?: boolean;\n  }\n}\n\n// Macro related types\nexport interface Macro {\n  id: string;\n  title: string;\n  description: string;\n  pattern: UserEvent[];\n  status: 'pending' | 'approved' | 'rejected';\n}\n\nexport interface MacroResponse {\n  success: boolean;\n  macros: Macro[];\n}","\nimport { v4 as uuidv4 } from 'uuid';\nimport { UserEvent, EventType, ClickEvent, ScrollEvent, FocusEvent } from './types';\n\n// Types for pattern detection\nexport interface DetectedPattern {\n  events: UserEvent[];\n  frequency: number;\n  confidence: number;\n  domain: string;\n}\n\n// Types for macro generation\nexport interface Macro {\n  id: string;\n  title: string;\n  description: string;\n  keybind: string;\n  isApproved: boolean;\n  applications: string[];\n  steps: MacroStep[];\n}\n\nexport interface MacroStep {\n  app: string;\n  action: string;\n  args: Record<string, any>;\n}\n\n// Helper function to generate a descriptive title from events\nfunction generateMacroTitle(events: UserEvent[]): string {\n  // Group events by type\n  const eventCounts = events.reduce((acc, event) => {\n    acc[event.event_type] = (acc[event.event_type] || 0) + 1;\n    return acc;\n  }, {} as Record<EventType, number>);\n\n  // Generate title based on event types and counts\n  const parts: string[] = [];\n  \n  if (eventCounts[EventType.CLICK]) {\n    parts.push(`${eventCounts[EventType.CLICK]} Click${eventCounts[EventType.CLICK] > 1 ? 's' : ''}`);\n  }\n  if (eventCounts[EventType.FOCUS]) {\n    parts.push(`${eventCounts[EventType.FOCUS]} Focus${eventCounts[EventType.FOCUS] > 1 ? 'es' : ''}`);\n  }\n  if (eventCounts[EventType.SCROLL]) {\n    parts.push(`${eventCounts[EventType.SCROLL]} Scroll${eventCounts[EventType.SCROLL] > 1 ? 's' : ''}`);\n  }\n\n  return parts.join(' + ');\n}\n\n// Helper function to generate a natural language description\nfunction generateMacroDescription(events: UserEvent[], domain: string): string {\n  const eventDescriptions = events.map(event => {\n    switch (event.event_type) {\n      case EventType.CLICK:\n        return `click on ${(event as ClickEvent).selector || 'element'}`;\n      case EventType.FOCUS:\n        return `focus ${(event as FocusEvent).state}`;\n      case EventType.SCROLL:\n        return `scroll to ${(event as ScrollEvent).scrollY}px`;\n      default:\n        return event.event_type;\n    }\n  });\n\n  return `Automates ${eventDescriptions.join(' â†’ ')} in ${domain}`;\n}\n\n// Main function to convert a detected pattern into a macro\nexport function createMacroFromPattern(pattern: DetectedPattern): Macro {\n  const title = generateMacroTitle(pattern.events);\n  const description = generateMacroDescription(pattern.events, pattern.domain);\n\n  return {\n    id: uuidv4(),\n    title,\n    description,\n    keybind: '', // Will be set by user\n    isApproved: false,\n    applications: [pattern.domain],\n    steps: pattern.events.map(event => ({\n      app: pattern.domain,\n      action: event.event_type,\n      args: {\n        selector: (event as ClickEvent).selector,\n        scrollY: (event as ScrollEvent).scrollY,\n        state: (event as FocusEvent).state,\n        // Add other relevant event properties\n      }\n    }))\n  };\n}\n\n// Function to suggest macros based on detected patterns\nexport function suggestMacros(patterns: DetectedPattern[]): Macro[] {\n  // Filter patterns by confidence and frequency\n  const significantPatterns = patterns.filter(\n    pattern => pattern.confidence > 0.7 && pattern.frequency > 3\n  );\n\n  // Convert patterns to macros\n  return significantPatterns.map(createMacroFromPattern);\n} ","import { UserEvent } from './types';\nimport { DetectedPattern, suggestMacros, Macro } from './macro_recommender';\n\n// Function to process events and detect patterns\nexport async function processEvents(events: UserEvent[]): Promise<Macro[]> {\n  try {\n    // Group events by domain\n    const eventsByDomain = events.reduce((acc, event) => {\n      const domain = new URL(event.url).hostname;\n      if (!acc[domain]) {\n        acc[domain] = [];\n      }\n      acc[domain].push(event);\n      return acc;\n    }, {} as Record<string, UserEvent[]>);\n\n    // Detect patterns for each domain\n    const patterns: DetectedPattern[] = [];\n    \n    for (const [domain, domainEvents] of Object.entries(eventsByDomain)) {\n      // Sort events by timestamp\n      const sortedEvents = domainEvents.sort((a, b) => \n        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime()\n      );\n\n      // Look for repeated sequences of events\n      const sequences = findRepeatedSequences(sortedEvents);\n      \n      // Convert sequences to patterns\n      sequences.forEach(sequence => {\n        patterns.push({\n          events: sequence.events,\n          frequency: sequence.frequency,\n          confidence: calculateConfidence(sequence),\n          domain\n        });\n      });\n    }\n\n    // Generate macro suggestions\n    return suggestMacros(patterns);\n  } catch (error) {\n    console.error('Error processing events:', error);\n    return [];\n  }\n}\n\ninterface Sequence {\n  events: UserEvent[];\n  frequency: number;\n}\n\n// Helper function to find repeated sequences of events\nfunction findRepeatedSequences(events: UserEvent[]): Sequence[] {\n  const sequences: Sequence[] = [];\n  const minSequenceLength = 2;\n  const maxSequenceLength = 5;\n  const minFrequency = 3;\n\n  // Try different sequence lengths\n  for (let length = minSequenceLength; length <= maxSequenceLength; length++) {\n    // Look for sequences of this length\n    for (let i = 0; i <= events.length - length; i++) {\n      const sequence = events.slice(i, i + length);\n      const sequenceStr = JSON.stringify(sequence);\n      \n      // Count occurrences of this sequence\n      let frequency = 1;\n      for (let j = i + length; j <= events.length - length; j++) {\n        const compareSequence = events.slice(j, j + length);\n        if (JSON.stringify(compareSequence) === sequenceStr) {\n          frequency++;\n        }\n      }\n\n      // If sequence appears frequently enough, add it\n      if (frequency >= minFrequency) {\n        sequences.push({\n          events: sequence,\n          frequency\n        });\n      }\n    }\n  }\n\n  return sequences;\n}\n\n// Helper function to calculate pattern confidence\nfunction calculateConfidence(sequence: Sequence): number {\n  // Base confidence on frequency and sequence length\n  const baseConfidence = Math.min(sequence.frequency / 5, 1);\n  const lengthFactor = Math.min(sequence.events.length / 5, 1);\n  \n  return (baseConfidence + lengthFactor) / 2;\n} ","import { UserEvent, Message } from './types';\nimport { processEvents } from './pattern_integration';\nimport { Macro } from './macro_recommender';\n\n// ==================== CONFIGURATION ====================\n\n// API Configuration\nconst API_CONFIG = {\n  endpoint: 'http://localhost:3000/api/events',\n  timeout: 10000,\n  maxRetries: 3,\n  retryDelay: 1000,\n} as const;\n\n// Performance Configuration  \nconst PERFORMANCE_CONFIG = {\n  maxBatchSize: 50, // MAX 50 events per batch to prevent 413 errors\n  maxBatchSizeBytes: 100 * 1024, // 100KB max payload\n  batchIntervalMinutes: 2, // Send every 2 minutes (reduced from 5)\n  maxStoredEvents: 1000, // Prevent infinite accumulation\n  storageCleanupThreshold: 0.7, // Clean up at 70%\n  keepaliveIntervalMinutes: 1, // Reduced service worker overhead\n  patternAnalysisIntervalMinutes: 30, // Analyze patterns every 30 minutes\n} as const;\n\n// Storage Keys\nconst STORAGE_KEYS = {\n  events: 'maqroUserEvents',\n  stats: 'maqroStats',\n  suggestedMacros: 'maqroSuggestedMacros',\n} as const;\n\n// Alarm Names\nconst ALARM_NAMES = {\n  batchSend: 'maqroBatchSendAlarm',\n  keepalive: 'maqroKeepaliveAlarm',\n  patternAnalysis: 'maqroPatternAnalysisAlarm',\n} as const;\n\n// Feature Flags\nconst FEATURE_FLAGS = {\n  enablePerformanceLogging: false, // Reduce console spam\n  enableRetryLogic: true,\n  enableChunkedSending: true,\n} as const;\n\n// ==================== STATE MANAGEMENT ====================\n\ninterface ExtensionState {\n  isCollecting: boolean;\n  userManuallyPaused: boolean;\n  isSendingBatch: boolean;\n  lastSendAttempt: number;\n  sendFailureCount: number;\n  totalEventsSent: number;\n  totalEventsDropped: number;\n}\n\nconst state: ExtensionState = {\n  isCollecting: true,\n  userManuallyPaused: false,\n  isSendingBatch: false,\n  lastSendAttempt: 0,\n  sendFailureCount: 0,\n  totalEventsSent: 0,\n  totalEventsDropped: 0,\n};\n\n// ==================== UTILITY FUNCTIONS ====================\n\n/**\n * Enhanced logging with performance mode toggle\n */\nfunction log(level: 'info' | 'warn' | 'error', message: string, ...args: any[]) {\n  const prefix = 'Maqro:';\n  if (level === 'error' || FEATURE_FLAGS.enablePerformanceLogging) {\n    console[level](prefix, message, ...args);\n  }\n}\n\n/**\n * Calculate size of events array in bytes\n */\nfunction calculateEventsSizeBytes(events: UserEvent[]): number {\n  return new TextEncoder().encode(JSON.stringify(events)).length;\n}\n\n/**\n * Split events into chunks that respect size limits\n */\nfunction chunkEvents(events: UserEvent[]): UserEvent[][] {\n  const chunks: UserEvent[][] = [];\n  let currentChunk: UserEvent[] = [];\n  let currentSize = 0;\n  \n  for (const event of events) {\n    const eventSize = calculateEventsSizeBytes([event]);\n    \n    // If adding this event would exceed limits, start new chunk\n    if (currentChunk.length >= PERFORMANCE_CONFIG.maxBatchSize || \n        currentSize + eventSize > PERFORMANCE_CONFIG.maxBatchSizeBytes) {\n      if (currentChunk.length > 0) {\n        chunks.push(currentChunk);\n        currentChunk = [];\n        currentSize = 0;\n      }\n    }\n    \n    currentChunk.push(event);\n    currentSize += eventSize;\n  }\n  \n  if (currentChunk.length > 0) {\n    chunks.push(currentChunk);\n  }\n  \n  return chunks;\n}\n\n// ==================== CORE FUNCTIONS ====================\n\n/**\n * Enhanced batch sending with chunking and retry logic\n */\nasync function sendBatchToServer(): Promise<void> {\n  if (state.isSendingBatch) {\n    log('info', 'Batch send already in progress. Skipping.');\n    return;\n  }\n  \n  state.isSendingBatch = true;\n  state.lastSendAttempt = Date.now();\n  \n  try {\n    // Get events from storage\n    const result = await chrome.storage.local.get(STORAGE_KEYS.events);\n    const allEvents: UserEvent[] = result[STORAGE_KEYS.events] || [];\n    \n    if (allEvents.length === 0) {\n      log('info', 'No events to send.');\n      return;\n    }\n    \n    // Implement chunking to prevent 413 errors\n    const chunks = chunkEvents(allEvents);\n    log('info', `Sending ${allEvents.length} events in ${chunks.length} chunks`);\n    \n    let successfulChunks = 0;\n    let failedChunks = 0;\n    \n    // Send each chunk with retry logic\n    for (let i = 0; i < chunks.length; i++) {\n      const chunk = chunks[i];\n      const success = await sendChunkWithRetry(chunk, i + 1, chunks.length);\n      \n      if (success) {\n        successfulChunks++;\n        state.totalEventsSent += chunk.length;\n      } else {\n        failedChunks++;\n        state.totalEventsDropped += chunk.length;\n      }\n    }\n    \n    // Only clear storage if all chunks sent successfully\n    if (failedChunks === 0) {\n      await chrome.storage.local.remove(STORAGE_KEYS.events);\n      log('info', `All ${successfulChunks} chunks sent successfully. Storage cleared.`);\n      state.sendFailureCount = 0;\n    } else {\n      log('error', `${failedChunks}/${chunks.length} chunks failed. Keeping events in storage.`);\n      state.sendFailureCount++;\n    }\n    \n  } catch (error: any) {\n    log('error', 'Error in batch send process:', error);\n    state.sendFailureCount++;\n  } finally {\n    state.isSendingBatch = false;\n  }\n}\n\n/**\n * Send a single chunk with retry logic\n */\nasync function sendChunkWithRetry(events: UserEvent[], chunkNum: number, totalChunks: number): Promise<boolean> {\n  let retryCount = 0;\n  \n  while (retryCount < API_CONFIG.maxRetries) {\n    try {\n      const payload = JSON.stringify({ events });\n      \n      log('info', `Sending chunk ${chunkNum}/${totalChunks} (${events.length} events, ${payload.length} bytes)`);\n      \n      const response = await fetch(API_CONFIG.endpoint, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: payload,\n        signal: AbortSignal.timeout(API_CONFIG.timeout),\n      });\n      \n      if (!response.ok) {\n        const errorText = await response.text();\n        throw new Error(`HTTP ${response.status}: ${errorText}`);\n      }\n      \n      log('info', `Chunk ${chunkNum}/${totalChunks} sent successfully`);\n      return true;\n      \n    } catch (error: any) {\n      retryCount++;\n      \n      if (error.name === 'AbortError') {\n        log('error', `Chunk ${chunkNum} timeout (attempt ${retryCount})`);\n      } else if (error.message.includes('413')) {\n        log('error', `Chunk ${chunkNum} too large (413 error). This chunk will be dropped.`);\n        return false; // Don't retry 413 errors\n      } else {\n        log('error', `Chunk ${chunkNum} failed (attempt ${retryCount}):`, error.message);\n      }\n      \n      if (retryCount < API_CONFIG.maxRetries) {\n        await new Promise(resolve => setTimeout(resolve, API_CONFIG.retryDelay * retryCount));\n      }\n    }\n  }\n  \n  log('error', `Chunk ${chunkNum} failed after ${API_CONFIG.maxRetries} attempts`);\n  return false;\n}\n\n/**\n * Enhanced event storage with size management\n */\nasync function handleUserEvent(event: UserEvent): Promise<void> {\n  if (!state.isCollecting) {\n    return;\n  }\n  \n  try {\n    const result = await chrome.storage.local.get(STORAGE_KEYS.events);\n    let events: UserEvent[] = result[STORAGE_KEYS.events] || [];\n    \n    // Prevent memory bloat - remove oldest events if we hit the limit\n    if (events.length >= PERFORMANCE_CONFIG.maxStoredEvents) {\n      const eventsToRemove = events.length - PERFORMANCE_CONFIG.maxStoredEvents + 1;\n      events = events.slice(eventsToRemove);\n      state.totalEventsDropped += eventsToRemove;\n      log('warn', `Dropped ${eventsToRemove} old events to prevent memory bloat`);\n    }\n    \n    events.push(event);\n    await chrome.storage.local.set({ [STORAGE_KEYS.events]: events });\n    \n    // Check if we need to send early\n    checkStorageAndTriggerSend(events);\n    \n  } catch (error: any) {\n    log('error', 'Error storing event:', error);\n  }\n}\n\n/**\n * Optimized storage check with better thresholds\n */\nfunction checkStorageAndTriggerSend(events: UserEvent[]): void {\n  // Trigger send based on event count or storage usage\n  if (events.length >= PERFORMANCE_CONFIG.maxBatchSize) {\n    log('info', 'Event count threshold reached. Triggering send.');\n    sendBatchToServer();\n    return;\n  }\n  \n  // Check storage size\n  chrome.storage.local.getBytesInUse([STORAGE_KEYS.events], (bytesInUse) => {\n    if (chrome.runtime.lastError) {\n      log('error', 'Error checking storage usage:', chrome.runtime.lastError.message);\n      return;\n    }\n    \n    const storageQuota = chrome.storage.local.QUOTA_BYTES || 5 * 1024 * 1024;\n    const usagePercent = bytesInUse / storageQuota;\n    \n    if (usagePercent > PERFORMANCE_CONFIG.storageCleanupThreshold) {\n      log('info', `Storage threshold reached (${Math.round(usagePercent * 100)}%). Triggering send.`);\n      sendBatchToServer();\n    }\n  });\n}\n\n// ==================== MESSAGE HANDLING ====================\n\nchrome.runtime.onMessage.addListener((message: Message, sender, sendResponse) => {\n  // Reduce logging noise\n  if (FEATURE_FLAGS.enablePerformanceLogging) {\n    log('info', 'Received message', message);\n  }\n  \n  switch (message.type) {\n    case 'USER_EVENT':\n      if (message.event) {\n        handleUserEvent(message.event);\n        sendResponse({ success: true });\n      }\n      break;\n      \n    case 'TOGGLE_COLLECTION':\n      if (typeof message.enabled === 'boolean') {\n        state.userManuallyPaused = !message.enabled;\n        state.isCollecting = message.enabled;\n        \n        log('info', `Collection ${state.isCollecting ? 'enabled' : 'disabled'} by user`);\n        broadcastCollectionStateToAllTabs(state.isCollecting);\n        sendResponse({ success: true, isCollecting: state.isCollecting });\n        \n        // Send pending events when stopping\n        if (!state.isCollecting) {\n          sendBatchToServer();\n        }\n      }\n      return true;\n      \n    case 'GET_OPERATIONAL_STATE':\n      sendResponse({ \n        success: true, \n        isCollecting: state.isCollecting,\n        stats: {\n          totalEventsSent: state.totalEventsSent,\n          totalEventsDropped: state.totalEventsDropped,\n          sendFailureCount: state.sendFailureCount\n        }\n      });\n      return true;\n      \n    case 'HEALTH_CHECK':\n      sendResponse({ success: true, isAlive: true });\n      return true;\n  }\n});\n\n// ==================== TAB MANAGEMENT ====================\n\n/**\n * Optimized tab broadcasting with better error handling\n */\nasync function broadcastCollectionStateToAllTabs(enabled: boolean): Promise<void> {\n  try {\n    const tabs = await chrome.tabs.query({\n      url: ['http://*/*', 'https://*/*'], \n      status: 'complete'\n    });\n    \n    log('info', `Broadcasting collection state (${enabled}) to ${tabs.length} tabs`);\n    \n    const sendPromises = tabs\n      .filter(tab => tab.id)\n      .map(tab => \n        chrome.tabs.sendMessage(tab.id!, { type: 'TOGGLE_COLLECTION', enabled })\n          .catch(() => {\n            // Silently ignore connection errors - they're expected\n          })\n      );\n    \n    await Promise.allSettled(sendPromises);\n    \n  } catch (error: any) {\n    log('error', 'Error broadcasting to tabs:', error);\n  }\n}\n\n// ==================== INITIALIZATION ====================\n\n/**\n * Set up alarms and initial state\n */\nasync function initializeExtension(): Promise<void> {\n  log('info', 'Initializing Maqro extension...');\n  \n  // Create alarms\n  const alarms = [\n    { name: ALARM_NAMES.batchSend, periodInMinutes: PERFORMANCE_CONFIG.batchIntervalMinutes },\n    { name: ALARM_NAMES.keepalive, periodInMinutes: PERFORMANCE_CONFIG.keepaliveIntervalMinutes },\n    { name: ALARM_NAMES.patternAnalysis, periodInMinutes: PERFORMANCE_CONFIG.patternAnalysisIntervalMinutes },\n  ];\n  \n  for (const alarm of alarms) {\n    const existing = await chrome.alarms.get(alarm.name);\n    if (!existing) {\n      await chrome.alarms.create(alarm.name, { periodInMinutes: alarm.periodInMinutes });\n      log('info', `Created ${alarm.name} alarm`);\n    }\n  }\n  \n  // Set initial state\n  state.isCollecting = true;\n  state.userManuallyPaused = false;\n  \n  // Broadcast initial state\n  await broadcastCollectionStateToAllTabs(state.isCollecting);\n  \n  log('info', 'Extension initialization complete');\n}\n\n// ==================== EVENT LISTENERS ====================\n\nchrome.runtime.onInstalled.addListener(initializeExtension);\nchrome.runtime.onStartup.addListener(initializeExtension);\n\n// Alarm handler\nchrome.alarms.onAlarm.addListener((alarm) => {\n  switch (alarm.name) {\n    case ALARM_NAMES.batchSend:\n      log('info', 'Batch send alarm triggered');\n      sendBatchToServer();\n      break;\n      \n    case ALARM_NAMES.keepalive:\n      // Minimal action to keep service worker alive\n      if (FEATURE_FLAGS.enablePerformanceLogging) {\n        log('info', 'Keepalive alarm triggered');\n      }\n      break;\n      \n    case ALARM_NAMES.patternAnalysis:\n      log('info', 'Pattern analysis alarm triggered');\n      analyzePatterns();\n      break;\n  }\n});\n\n// Enhanced tab injection with better performance\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && \n      tab.url?.startsWith('http') && \n      !tab.url.includes('chrome://') &&\n      !tab.url.includes('chrome-extension://')) {\n    \n    // Delay injection to ensure page is fully loaded\n    setTimeout(() => {\n      chrome.scripting.executeScript({\n        target: { tabId },\n        files: ['content.js']\n      }).then(() => {\n        log('info', `Content script injected into tab ${tabId}`);\n        \n        // Give content script more time to initialize before sending state\n        setTimeout(() => {\n          chrome.tabs.sendMessage(tabId, { \n            type: 'TOGGLE_COLLECTION', \n            enabled: state.isCollecting \n          }).catch((error) => {\n            // Only log if it's not a common connection error\n            if (!error.message.includes('Could not establish connection') &&\n                !error.message.includes('receiving end does not exist')) {\n              log('warn', `Failed to send initial state to tab ${tabId}: ${error.message}`);\n            }\n          });\n        }, 500); // Increased delay to allow content script to fully initialize\n      }).catch((error) => {\n        // Only log injection errors for pages we should be able to inject into\n        if (!error.message.includes('Cannot access') && \n            !error.message.includes('The extensions gallery cannot be scripted')) {\n          log('warn', `Content script injection failed for tab ${tabId}: ${error.message}`);\n        }\n      });\n    }, 200); // Initial delay to ensure page is stable\n  }\n});\n\n// Extension icon click handler\nchrome.action.onClicked.addListener(() => {\n  const newState = !state.isCollecting;\n  state.userManuallyPaused = !newState;\n  state.isCollecting = newState;\n  \n  log('info', `Extension toggled: ${newState ? 'ON' : 'OFF'}`);\n  broadcastCollectionStateToAllTabs(state.isCollecting);\n  \n  if (!state.isCollecting) {\n    sendBatchToServer();\n  }\n});\n\n// Idle state management (simplified)\nchrome.idle.onStateChanged.addListener((idleState) => {\n  if (!state.userManuallyPaused) {\n    const shouldCollect = idleState === 'active';\n    if (state.isCollecting !== shouldCollect) {\n      state.isCollecting = shouldCollect;\n      broadcastCollectionStateToAllTabs(state.isCollecting);\n    }\n  }\n});\n\n// Window focus management (simplified)\nchrome.windows.onFocusChanged.addListener((windowId) => {\n  if (!state.userManuallyPaused) {\n    const shouldCollect = windowId !== chrome.windows.WINDOW_ID_NONE;\n    if (state.isCollecting !== shouldCollect) {\n      state.isCollecting = shouldCollect;\n      broadcastCollectionStateToAllTabs(state.isCollecting);\n    }\n  }\n});\n\n// Add after initializeExtension function\nasync function analyzePatterns(): Promise<void> {\n  try {\n    // Get events from storage\n    const result = await chrome.storage.local.get(STORAGE_KEYS.events);\n    const events: UserEvent[] = result[STORAGE_KEYS.events] || [];\n    \n    if (events.length === 0) {\n      log('info', 'No events to analyze for patterns.');\n      return;\n    }\n\n    // Process events and get macro suggestions\n    const suggestedMacros = await processEvents(events);\n    \n    if (suggestedMacros.length > 0) {\n      // Get existing suggested macros\n      const existingResult = await chrome.storage.local.get(STORAGE_KEYS.suggestedMacros);\n      const existingMacros = existingResult[STORAGE_KEYS.suggestedMacros] || [];\n      \n      // Merge new suggestions with existing ones, avoiding duplicates\n      const mergedMacros = [...existingMacros];\n      for (const newMacro of suggestedMacros) {\n        const isDuplicate = existingMacros.some(\n          (existing: Macro) => existing.title === newMacro.title && \n                     existing.applications[0] === newMacro.applications[0]\n        );\n        if (!isDuplicate) {\n          mergedMacros.push(newMacro);\n        }\n      }\n      \n      // Save updated suggestions\n      await chrome.storage.local.set({ [STORAGE_KEYS.suggestedMacros]: mergedMacros });\n      log('info', `Added ${suggestedMacros.length} new macro suggestions.`);\n    }\n  } catch (error) {\n    log('error', 'Error analyzing patterns:', error);\n  }\n}\n  "],"names":["randomUUID","crypto","bind","getRandomValues","rnds8","Uint8Array","rng","Error","byteToHex","i","push","toString","slice","options","buf","offset","rnds","random","arr","unsafeStringify","EventType","createMacroFromPattern","pattern","title","events","eventCounts","reduce","acc","event","event_type","parts","CLICK","FOCUS","SCROLL","join","generateMacroTitle","description","domain","map","selector","state","scrollY","id","keybind","isApproved","applications","steps","app","action","args","findRepeatedSequences","sequences","length","sequence","sequenceStr","JSON","stringify","frequency","j","compareSequence","calculateConfidence","Math","min","STORAGE_KEYS","ALARM_NAMES","isCollecting","userManuallyPaused","isSendingBatch","lastSendAttempt","sendFailureCount","totalEventsSent","totalEventsDropped","log","level","message","console","calculateEventsSizeBytes","TextEncoder","encode","async","sendBatchToServer","Date","now","allEvents","chrome","storage","local","get","chunks","currentChunk","currentSize","eventSize","chunkEvents","successfulChunks","failedChunks","chunk","sendChunkWithRetry","remove","error","chunkNum","totalChunks","retryCount","payload","response","fetch","method","headers","body","signal","AbortSignal","timeout","ok","errorText","text","status","name","includes","Promise","resolve","setTimeout","broadcastCollectionStateToAllTabs","enabled","tabs","query","url","sendPromises","filter","tab","sendMessage","type","catch","allSettled","initializeExtension","alarms","periodInMinutes","alarm","create","runtime","onMessage","addListener","sender","sendResponse","eventsToRemove","set","getBytesInUse","bytesInUse","lastError","usagePercent","QUOTA_BYTES","round","checkStorageAndTriggerSend","handleUserEvent","success","stats","isAlive","onInstalled","onStartup","onAlarm","suggestedMacros","eventsByDomain","URL","hostname","patterns","domainEvents","Object","entries","sort","a","b","timestamp","getTime","forEach","confidence","suggestMacros","processEvents","existingMacros","mergedMacros","newMacro","some","existing","analyzePatterns","onUpdated","tabId","changeInfo","startsWith","scripting","executeScript","target","files","then","onClicked","newState","idle","onStateChanged","idleState","shouldCollect","windows","onFocusChanged","windowId","WINDOW_ID_NONE"],"sourceRoot":""}