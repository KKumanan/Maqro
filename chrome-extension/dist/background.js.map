{"version":3,"file":"background.js","mappings":"mBAUA,IAAIA,GAAe,EACfC,GAAY,EAGhB,SAASC,EAAIC,GACXC,QAAQF,IAAI,oBAAqBC,EACnC,CA0DAE,eAAeC,IACb,GAAIL,EACFC,EAAI,oCADN,CAKAD,GAAY,EAEZ,IAEE,MACMM,SADeC,OAAOC,QAAQC,MAAMC,IAAI,WACXJ,QAAU,GAE7C,GAAsB,IAAlBA,EAAOK,OAET,YADAV,EAAI,qBAINA,EAAI,WAAWK,EAAOK,2BAGtB,MAAMC,QAAiBC,MA3Fd,mCA2FsC,CAC7CC,OAAQ,OACRC,QAAS,CAAE,eAAgB,oBAC3BC,KAAMC,KAAKC,UAAU,CAAEZ,aAGzB,IAAIM,EAASO,GAKX,MAAM,IAAIC,MAAM,yBAAyBR,EAASS,gBAH5Cd,OAAOC,QAAQC,MAAMa,OAAO,UAClCrB,EAAI,qBAAqBK,EAAOK,gBAIpC,CAAE,MAAOY,GACPtB,EAAI,0BAA0BsB,IAChC,C,QACEvB,GAAY,CACd,CAlCA,CAmCF,CA9FAO,OAAOiB,QAAQC,UAAUC,aAAY,CAACxB,EAASyB,EAAQC,KACrD,OAAQ1B,EAAQ2B,MACd,IAAK,cACC3B,EAAQI,QAAUwB,MAAMC,QAAQ7B,EAAQI,UAqBlDF,eAA4B4B,GAC1B,IACE/B,EAAI,YAAY+B,EAAUrB,iBAG1B,MAIMsB,EAAY,WAJG1B,OAAOC,QAAQC,MAAMC,IAAI,WACHJ,QAAU,MAGZ0B,GAGrCC,EAAUtB,OAAS,MACrBsB,EAAUC,OAAO,EAAGD,EAAUtB,OAAS,KACvCV,EAAI,wDAIAM,OAAOC,QAAQC,MAAM0B,IAAI,CAAE7B,OAAQ2B,IACzChC,EAAI,UAAUgC,EAAUtB,uBAGpBsB,EAAUtB,QA5DL,IA6DPN,GAEJ,CAAE,MAAOkB,GACPtB,EAAI,0BAA0BsB,IAChC,CACF,CAhDQa,CAAalC,EAAQI,QACrBsB,EAAa,CAAES,SAAS,KAE1B,MAEF,IAAK,oBACHtC,EAAeG,EAAQoC,QACvBrC,EAAI,eAAcF,EAAe,UAAY,aAsFnDK,eAA+BF,GAC7B,IACE,MAAMqC,QAAahC,OAAOgC,KAAKC,MAAM,CAAEC,IAAK,CAAC,aAAc,iBAC3D,IAAK,MAAMC,KAAOH,EACZG,EAAIC,IACNpC,OAAOgC,KAAKK,YAAYF,EAAIC,GAAIzC,GAAS2C,OAAM,QAKrD,CAAE,MAAOtB,GACPtB,EAAI,+BAA+BsB,IACrC,CACF,CAlGMuB,CAAgB,CAAEjB,KAAM,oBAAqBS,QAASvC,IACjDA,GAAcM,IACnBuB,EAAa,CAAES,SAAS,EAAMtC,iBAC9B,MAEF,IAAK,YACH6B,EAAa,CAAES,SAAS,EAAMtC,iBAElC,IA6FFQ,OAAOgC,KAAKQ,UAAUrB,aAAY,CAACsB,EAAOC,EAAYP,K,MAC1B,aAAtBO,EAAW5B,UACJ,QAAP,EAAAqB,EAAID,WAAG,eAAES,WAAW,UACnBR,EAAID,IAAIU,SAAS,cACjBT,EAAID,IAAIU,SAAS,wBAGpB5C,OAAO6C,UAAUC,cAAc,CAC7BC,OAAQ,CAAEN,SACVO,MAAO,CAAC,gBACPC,MAAK,KACNvD,EAAI,oCAAoC+C,KAGxCS,YAAW,KACTlD,OAAOgC,KAAKK,YAAYI,EAAO,CAC7BnB,KAAM,oBACNS,QAASvC,IACR8C,OAAM,QAEP,GACD,IAAI,IACNA,OAAM,QAGX,IAIFtC,OAAOiB,QAAQkC,YAAYhC,aAAY,KACrCzB,EAAI,uBACJF,GAAe,CAAI,IAGrBQ,OAAOiB,QAAQmC,UAAUjC,aAAY,KACnCzB,EAAI,qBACJF,GAAe,CAAI,IAIrB6D,YAAYvD,EAtKI,KAwKhBJ,EAAI,gC","sources":["webpack://macro-engine-activity-tracker/./src/background.ts"],"sourcesContent":["import { UserEvent } from './types';\n\n// Chrome Extension Conifguration\nconst CONFIG = {\n  serverUrl: 'http://localhost:3000/api/events',\n  batchSize: 20, // Send when we have 20+ events\n  sendInterval: 60000, // Send every minute\n};\n\n// State Management\nlet isCollecting = true;\nlet isSending = false;\n\n// Logging\nfunction log(message: string) {\n  console.log('Maqro Background:', message);\n}\n\n// Handle messages from content scripts\nchrome.runtime.onMessage.addListener((message, sender, sendResponse) => {\n  switch (message.type) {\n    case 'USER_EVENTS':\n      if (message.events && Array.isArray(message.events)) {\n        handleEvents(message.events);\n        sendResponse({ success: true });\n      }\n      break;\n      \n    case 'TOGGLE_COLLECTION':\n      isCollecting = message.enabled;\n      log(`Collection ${isCollecting ? 'enabled' : 'disabled'}`);\n      broadcastToTabs({ type: 'TOGGLE_COLLECTION', enabled: isCollecting });\n      if (!isCollecting) sendEventsToServer(); // Send remaining events\n      sendResponse({ success: true, isCollecting });\n      break;\n      \n    case 'GET_STATE':\n      sendResponse({ success: true, isCollecting });\n      break;\n  }\n});\n\n// Store events and trigger send if needed\nasync function handleEvents(newEvents: UserEvent[]) {\n  try {\n    log(`Received ${newEvents.length} events`);\n    \n    // Get existing events\n    const result = await chrome.storage.local.get('events');\n    const existingEvents: UserEvent[] = result.events || [];\n    \n    // Add new events\n    const allEvents = [...existingEvents, ...newEvents];\n    \n    // Limit total events to prevent memory issues\n    if (allEvents.length > 1000) {\n      allEvents.splice(0, allEvents.length - 1000); // Keep only last 1000\n      log('Trimmed old events to prevent memory overflow');\n    }\n    \n    // Save back to storage\n    await chrome.storage.local.set({ events: allEvents });\n    log(`Stored ${allEvents.length} total events`);\n    \n    // Send if we have enough events\n    if (allEvents.length >= CONFIG.batchSize) {\n      sendEventsToServer();\n    }\n  } catch (error) {\n    log(`Error handling events: ${error}`);\n  }\n}\n\n// Send events to server\nasync function sendEventsToServer() {\n  if (isSending) {\n    log('Already sending, skipping...');\n    return;\n  }\n  \n  isSending = true;\n  \n  try {\n    // Get events from storage\n    const result = await chrome.storage.local.get('events');\n    const events: UserEvent[] = result.events || [];\n    \n    if (events.length === 0) {\n      log('No events to send');\n      return;\n    }\n    \n    log(`Sending ${events.length} events to server`);\n    \n    // Send to server\n    const response = await fetch(CONFIG.serverUrl, {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify({ events }),\n    });\n    \n    if (response.ok) {\n      // Clear events from storage on success\n      await chrome.storage.local.remove('events');\n      log(`Successfully sent ${events.length} events`);\n    } else {\n      throw new Error(`Server responded with ${response.status}`);\n    }\n  } catch (error) {\n    log(`Failed to send events: ${error}`);\n  } finally {\n    isSending = false;\n  }\n}\n\n// Broadcast message to all tabs\nasync function broadcastToTabs(message: any) {\n  try {\n    const tabs = await chrome.tabs.query({ url: ['http://*/*', 'https://*/*'] });\n    for (const tab of tabs) {\n      if (tab.id) {\n        chrome.tabs.sendMessage(tab.id, message).catch(() => {\n          // Ignore connection errors - they're common\n        });\n      }\n    }\n  } catch (error) {\n    log(`Error broadcasting to tabs: ${error}`);\n  }\n}\n\n// Inject content script into new tabs\nchrome.tabs.onUpdated.addListener((tabId, changeInfo, tab) => {\n  if (changeInfo.status === 'complete' && \n      tab.url?.startsWith('http') && \n      !tab.url.includes('chrome://') &&\n      !tab.url.includes('chrome-extension://')) {\n    \n    // Inject content script\n    chrome.scripting.executeScript({\n      target: { tabId },\n      files: ['content.js']\n    }).then(() => {\n      log(`Injected content script into tab ${tabId}`);\n      \n      // Send current collection state\n      setTimeout(() => {\n        chrome.tabs.sendMessage(tabId, { \n          type: 'TOGGLE_COLLECTION', \n          enabled: isCollecting \n        }).catch(() => {\n          // Ignore errors\n        });\n      }, 500);\n    }).catch(() => {\n      // Ignore injection errors\n    });\n  }\n});\n\n// Initialize extension\nchrome.runtime.onInstalled.addListener(() => {\n  log('Extension installed');\n  isCollecting = true;\n});\n\nchrome.runtime.onStartup.addListener(() => {\n  log('Extension started');\n  isCollecting = true;\n});\n\n// Send events periodically\nsetInterval(sendEventsToServer, CONFIG.sendInterval);\n\nlog('Background script initialized');\n  "],"names":["isCollecting","isSending","log","message","console","async","sendEventsToServer","events","chrome","storage","local","get","length","response","fetch","method","headers","body","JSON","stringify","ok","Error","status","remove","error","runtime","onMessage","addListener","sender","sendResponse","type","Array","isArray","newEvents","allEvents","splice","set","handleEvents","success","enabled","tabs","query","url","tab","id","sendMessage","catch","broadcastToTabs","onUpdated","tabId","changeInfo","startsWith","includes","scripting","executeScript","target","files","then","setTimeout","onInstalled","onStartup","setInterval"],"sourceRoot":""}