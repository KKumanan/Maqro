{"version":3,"file":"popup.js","mappings":"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","sources":["webpack://macro-engine-activity-tracker/./src/popup.ts"],"sourcesContent":["import { UserEvent } from './types';\n\n// Remove local isCollecting state, will get from background\n// let isCollecting = true; \nlet serverStatus = 'checking';\n\n// Update UI based on collection state from background\nfunction updateStatus(collecting: boolean) {\n  const statusEl = document.getElementById('status')!;\n  const toggleButton = document.getElementById('toggleCollection')!;\n  \n  statusEl.textContent = collecting ? 'Collecting events...' : 'Collection Paused';\n  statusEl.className = `status ${collecting ? 'active' : 'inactive'}`;\n  toggleButton.textContent = collecting ? 'Stop Collection' : 'Start Collection';\n}\n\n// Format timestamp\nfunction formatTime(timestamp: string): string {\n  return new Date(timestamp).toLocaleTimeString();\n}\n\n// Add event to UI\nfunction addEvent(event: UserEvent) {\n  const eventsDiv = document.getElementById('events')!;\n  if (!eventsDiv) return;\n  const eventDiv = document.createElement('div');\n  eventDiv.className = 'event';\n  \n  eventDiv.innerHTML = `\n    <div class=\"event-type\">${event.event_type}</div>\n    <div class=\"event-time\">${formatTime(event.timestamp)}</div>\n    <div class=\"event-url\">${event.url}</div>\n  `;\n  \n  // Prepend to show newest first, but check if only placeholder is present\n  if (eventsDiv.firstChild && eventsDiv.firstChild.textContent === 'No events to display.' || eventsDiv.firstChild?.textContent === 'Could not fetch events.') {\n    eventsDiv.innerHTML = ''; // Clear placeholder\n  }\n  eventsDiv.insertBefore(eventDiv, eventsDiv.firstChild);\n}\n\n// Check server status\nasync function checkServerStatus() {\n  const serverStatusEl = document.getElementById('serverStatus')!;\n  if (!serverStatusEl) return;\n  try {\n    const response = await fetch('http://localhost:3000/api/events');\n    if (response.ok) {\n      serverStatus = 'connected';\n      serverStatusEl.textContent = 'Server: Connected';\n      serverStatusEl.className = 'server-status connected';\n    } else {\n      throw new Error('Server responded with error');\n    }\n  } catch (error) {\n    serverStatus = 'disconnected';\n    serverStatusEl.textContent = 'Server: Disconnected';\n    serverStatusEl.className = 'server-status disconnected';\n    console.error('Server connection error:', error);\n  }\n}\n\n// Fetch events from API\nasync function fetchEvents() {\n  const eventsDiv = document.getElementById('events')!;\n  if (!eventsDiv) return;\n\n  if (serverStatus !== 'connected') {\n    await checkServerStatus();\n    if (serverStatus !== 'connected') {\n        eventsDiv.textContent = 'Server disconnected. Cannot fetch events.';\n        return;\n    }\n  }\n\n  try {\n    const response = await fetch('http://localhost:3000/api/events');\n    if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${await response.text()}`);\n    }\n    const data = await response.json();\n    \n    eventsDiv.innerHTML = ''; // Clear previous events or placeholder\n    \n    if (data.events && Array.isArray(data.events) && data.events.length > 0) {\n        data.events.forEach((event: UserEvent) => addEvent(event));\n    } else {\n        eventsDiv.textContent = 'No events to display.';\n    }\n  } catch (error: any) {\n    console.error('Error fetching events:', error.message);\n    serverStatus = 'disconnected';\n    const serverStatusEl = document.getElementById('serverStatus');\n    if (serverStatusEl) {\n        serverStatusEl.textContent = 'Server: Disconnected';\n        serverStatusEl.className = 'server-status disconnected';\n    }\n    eventsDiv.textContent = 'Could not fetch events.';\n  }\n}\n\n// Clear events\nasync function clearEvents() {\n  const eventsDiv = document.getElementById('events')!;\n  if (!eventsDiv) return;\n\n  if (serverStatus !== 'connected') {\n    await checkServerStatus();\n    if (serverStatus !== 'connected') {\n      alert('Cannot clear events: Server is not connected');\n      return;\n    }\n  }\n\n  try {\n    const response = await fetch('http://localhost:3000/api/events', { \n      method: 'DELETE' \n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to clear events: ${response.status} ${await response.text()}`);\n    }\n    \n    eventsDiv.innerHTML = 'No events to display.'; // Clear displayed events\n    console.log('Events cleared from server and UI');\n  } catch (error: any) {\n    console.error('Error clearing events:', error.message);\n    alert('Failed to clear events. Please try again.');\n  }\n}\n\n// Initialize popup\ndocument.addEventListener('DOMContentLoaded', () => {\n  const toggleButton = document.getElementById('toggleCollection')!;\n  const clearButton = document.getElementById('clearEvents')!;\n  const serverStatusEl = document.getElementById('serverStatus');\n\n  // Set up server status element if it wasn't hardcoded (it is, but good practice if it could be dynamic)\n  if (!serverStatusEl) {\n    const statusDiv = document.createElement('div');\n    statusDiv.id = 'serverStatus';\n    statusDiv.className = 'server-status checking';\n    statusDiv.textContent = 'Server: Checking...';\n    document.body.insertBefore(statusDiv, document.body.firstChild);\n  }\n\n  // Get initial collection state from background script\n  chrome.runtime.sendMessage({ type: 'GET_OPERATIONAL_STATE' }, (response) => {\n    if (chrome.runtime.lastError) {\n      console.error('Error getting initial operational state:', chrome.runtime.lastError.message);\n      updateStatus(true); // Fallback UI to 'Collecting'\n      return;\n    }\n    if (response && typeof response.isCollecting === 'boolean') {\n      updateStatus(response.isCollecting);\n    } else {\n      console.error('Invalid response for GET_OPERATIONAL_STATE:', response);\n      updateStatus(true); // Fallback\n    }\n  });\n\n  toggleButton.addEventListener('click', () => {\n    // Get the current state displayed in the UI to determine the new desired state\n    const currentUIText = toggleButton.textContent || '';\n    const newDesiredState = currentUIText === 'Stop Collection'; // If it says Stop, user wants to stop (new state false)\n    const intendedState = !newDesiredState; // So if user wants to stop, enabled is false\n\n    // Optimistically update UI\n    updateStatus(intendedState);\n    \n    // Send message to background to change the collection state\n    chrome.runtime.sendMessage({ \n      type: 'TOGGLE_COLLECTION', \n      enabled: intendedState \n    }, (bgResponse) => {\n      if (chrome.runtime.lastError) {\n        console.error('Error toggling collection state:', chrome.runtime.lastError.message);\n        // Revert UI if error communication with background\n        updateStatus(!intendedState); \n      } else if (bgResponse && bgResponse.success && typeof bgResponse.isCollecting === 'boolean') {\n        console.log('Collection state successfully updated by background to:', bgResponse.isCollecting);\n        // Ensure UI matches the confirmed state from background, in case it differs from optimistic update\n        updateStatus(bgResponse.isCollecting);\n      } else {\n          console.error('Background failed to confirm toggle or invalid response:', bgResponse);\n          updateStatus(!intendedState); // Revert UI\n      }\n    });\n  });\n  \n  clearButton.addEventListener('click', clearEvents);\n  \n  checkServerStatus();\n  fetchEvents();\n  setInterval(fetchEvents, 5000);\n});\n"],"names":["serverStatus","updateStatus","collecting","statusEl","document","getElementById","toggleButton","textContent","className","async","checkServerStatus","serverStatusEl","fetch","ok","Error","error","console","fetchEvents","eventsDiv","response","status","text","data","json","innerHTML","events","Array","isArray","length","forEach","event","eventDiv","createElement","timestamp","event_type","Date","toLocaleTimeString","url","firstChild","insertBefore","addEvent","message","clearEvents","method","log","alert","addEventListener","clearButton","statusDiv","id","body","chrome","runtime","sendMessage","type","lastError","isCollecting","intendedState","enabled","bgResponse","success","setInterval"],"sourceRoot":""}