{"version":3,"file":"popup.js","mappings":"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","sources":["webpack://macro-engine-activity-tracker/./src/popup.ts"],"sourcesContent":["/// <reference types=\"chrome\"/>\n\nimport { UserEvent, Macro, OperationalStateResponse, ToggleCollectionResponse } from './types';\n\n// Remove local isCollecting state, will get from background\n// let isCollecting = true; \nlet serverStatus = 'checking';\n\n// Update UI based on collection state from background\nfunction updateStatus(collecting: boolean) {\n  const statusEl = document.getElementById('status')!;\n  const toggleButton = document.getElementById('toggleCollection')!;\n  \n  statusEl.textContent = collecting ? 'Collecting events...' : 'Collection Paused';\n  statusEl.className = `status ${collecting ? 'active' : 'inactive'}`;\n  toggleButton.textContent = collecting ? 'Stop Collection' : 'Start Collection';\n}\n\n// Format timestamp\nfunction formatTime(timestamp: string): string {\n  return new Date(timestamp).toLocaleTimeString();\n}\n\n// Add event to UI\nfunction addEvent(event: UserEvent) {\n  const eventsDiv = document.getElementById('events')!;\n  if (!eventsDiv) return;\n  const eventDiv = document.createElement('div');\n  eventDiv.className = 'event';\n  \n  eventDiv.innerHTML = `\n    <div class=\"event-type\">${event.event_type}</div>\n    <div class=\"event-time\">${formatTime(event.timestamp)}</div>\n    <div class=\"event-url\">${event.url}</div>\n  `;\n  \n  // Prepend to show newest first, but check if only placeholder is present\n  if (eventsDiv.firstChild && eventsDiv.firstChild.textContent === 'No events to display.' || eventsDiv.firstChild?.textContent === 'Could not fetch events.') {\n    eventsDiv.innerHTML = ''; // Clear placeholder\n  }\n  eventsDiv.insertBefore(eventDiv, eventsDiv.firstChild);\n}\n\n// Check server status\nasync function checkServerStatus() {\n  const serverStatusEl = document.getElementById('serverStatus')!;\n  if (!serverStatusEl) return;\n  try {\n    const response = await fetch('http://localhost:3000/api/events');\n    if (response.ok) {\n      serverStatus = 'connected';\n      serverStatusEl.textContent = 'Server: Connected';\n      serverStatusEl.className = 'server-status connected';\n    } else {\n      throw new Error('Server responded with error');\n    }\n  } catch (error) {\n    serverStatus = 'disconnected';\n    serverStatusEl.textContent = 'Server: Disconnected';\n    serverStatusEl.className = 'server-status disconnected';\n    console.error('Server connection error:', error);\n  }\n}\n\n// Fetch events from API\nasync function fetchEvents() {\n  const eventsDiv = document.getElementById('events')!;\n  if (!eventsDiv) return;\n\n  if (serverStatus !== 'connected') {\n    await checkServerStatus();\n    if (serverStatus !== 'connected') {\n        eventsDiv.textContent = 'Server disconnected. Cannot fetch events.';\n        return;\n    }\n  }\n\n  try {\n    const response = await fetch('http://localhost:3000/api/events');\n    if (!response.ok) {\n        throw new Error(`API error: ${response.status} ${await response.text()}`);\n    }\n    const data = await response.json();\n    \n    eventsDiv.innerHTML = ''; // Clear previous events or placeholder\n    \n    if (data.events && Array.isArray(data.events) && data.events.length > 0) {\n        data.events.forEach((event: UserEvent) => addEvent(event));\n    } else {\n        eventsDiv.textContent = 'No events to display.';\n    }\n  } catch (error: any) {\n    console.error('Error fetching events:', error.message);\n    serverStatus = 'disconnected';\n    const serverStatusEl = document.getElementById('serverStatus');\n    if (serverStatusEl) {\n        serverStatusEl.textContent = 'Server: Disconnected';\n        serverStatusEl.className = 'server-status disconnected';\n    }\n    eventsDiv.textContent = 'Could not fetch events.';\n  }\n}\n\n// Clear events\nasync function clearEvents() {\n  const eventsDiv = document.getElementById('events')!;\n  if (!eventsDiv) return;\n\n  if (serverStatus !== 'connected') {\n    await checkServerStatus();\n    if (serverStatus !== 'connected') {\n      alert('Cannot clear events: Server is not connected');\n      return;\n    }\n  }\n\n  try {\n    const response = await fetch('http://localhost:3000/api/events', { \n      method: 'DELETE' \n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to clear events: ${response.status} ${await response.text()}`);\n    }\n    \n    eventsDiv.innerHTML = 'No events to display.'; // Clear displayed events\n    console.log('Events cleared from server and UI');\n  } catch (error: any) {\n    console.error('Error clearing events:', error.message);\n    alert('Failed to clear events. Please try again.');\n  }\n}\n\n// Fetch macros from API\nasync function fetchMacros() {\n  const macroListDiv = document.getElementById('macroList')!;\n  if (!macroListDiv) return;\n\n  if (serverStatus !== 'connected') {\n    await checkServerStatus();\n    if (serverStatus !== 'connected') {\n      macroListDiv.innerHTML = '<div class=\"macro-item\"><div class=\"macro-title\">Server disconnected. Cannot fetch macros.</div></div>';\n      return;\n    }\n  }\n\n  try {\n    const response = await fetch('http://localhost:3000/api/macros');\n    if (!response.ok) {\n      throw new Error(`API error: ${response.status} ${await response.text()}`);\n    }\n    const data = await response.json();\n    \n    if (data.macros && Array.isArray(data.macros) && data.macros.length > 0) {\n      macroListDiv.innerHTML = data.macros\n        .filter((macro: Macro) => macro.status === 'pending')\n        .map((macro: Macro) => `\n          <div class=\"macro-item\" data-macro-id=\"${macro.id}\">\n            <div class=\"macro-title\">${macro.title}</div>\n            <div class=\"macro-description\">${macro.description}</div>\n            <div class=\"macro-actions\">\n              <button class=\"approve\" onclick=\"approveMacro('${macro.id}')\">Approve</button>\n              <button class=\"reject\" onclick=\"rejectMacro('${macro.id}')\">Reject</button>\n            </div>\n          </div>\n        `).join('');\n    } else {\n      macroListDiv.innerHTML = '<div class=\"macro-item\"><div class=\"macro-title\">No macros suggested yet.</div></div>';\n    }\n  } catch (error: any) {\n    console.error('Error fetching macros:', error.message);\n    macroListDiv.innerHTML = '<div class=\"macro-item\"><div class=\"macro-title\">Could not fetch macros.</div></div>';\n  }\n}\n\n// Handle macro approval\nasync function approveMacro(macroId: string) {\n  if (serverStatus !== 'connected') {\n    alert('Cannot approve macro: Server is not connected');\n    return;\n  }\n\n  try {\n    const response = await fetch(`http://localhost:3000/api/macros/${macroId}/approve`, {\n      method: 'POST'\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to approve macro: ${response.status} ${await response.text()}`);\n    }\n    \n    // Refresh macro list\n    fetchMacros();\n  } catch (error: any) {\n    console.error('Error approving macro:', error.message);\n    alert('Failed to approve macro. Please try again.');\n  }\n}\n\n// Handle macro rejection\nasync function rejectMacro(macroId: string) {\n  if (serverStatus !== 'connected') {\n    alert('Cannot reject macro: Server is not connected');\n    return;\n  }\n\n  try {\n    const response = await fetch(`http://localhost:3000/api/macros/${macroId}/reject`, {\n      method: 'POST'\n    });\n    \n    if (!response.ok) {\n      throw new Error(`Failed to reject macro: ${response.status} ${await response.text()}`);\n    }\n    \n    // Refresh macro list\n    fetchMacros();\n  } catch (error: any) {\n    console.error('Error rejecting macro:', error.message);\n    alert('Failed to reject macro. Please try again.');\n  }\n}\n\n// Initialize popup\ndocument.addEventListener('DOMContentLoaded', () => {\n  const toggleButton = document.getElementById('toggleCollection')!;\n  const clearButton = document.getElementById('clearEvents')!;\n  const serverStatusEl = document.getElementById('serverStatus');\n\n  // Set up server status element if it wasn't hardcoded (it is, but good practice if it could be dynamic)\n  if (!serverStatusEl) {\n    const statusDiv = document.createElement('div');\n    statusDiv.id = 'serverStatus';\n    statusDiv.className = 'server-status checking';\n    statusDiv.textContent = 'Server: Checking...';\n    document.body.insertBefore(statusDiv, document.body.firstChild);\n  }\n\n  // Get initial collection state from background script\n  chrome.runtime.sendMessage({ type: 'GET_OPERATIONAL_STATE' }, (response: OperationalStateResponse) => {\n    if (chrome.runtime.lastError) {\n      console.error('Error getting initial operational state:', chrome.runtime.lastError.message);\n      updateStatus(true); // Fallback UI to 'Collecting'\n      return;\n    }\n    if (response && typeof response.isCollecting === 'boolean') {\n      updateStatus(response.isCollecting);\n    } else {\n      console.error('Invalid response for GET_OPERATIONAL_STATE:', response);\n      updateStatus(true); // Fallback\n    }\n  });\n\n  toggleButton.addEventListener('click', () => {\n    // Get the current state displayed in the UI to determine the new desired state\n    const currentUIText = toggleButton.textContent || '';\n    const newDesiredState = currentUIText === 'Stop Collection'; // If it says Stop, user wants to stop (new state false)\n    const intendedState = !newDesiredState; // So if user wants to stop, enabled is false\n\n    // Optimistically update UI\n    updateStatus(intendedState);\n    \n    // Send message to background to change the collection state\n    chrome.runtime.sendMessage({ \n      type: 'TOGGLE_COLLECTION', \n      enabled: intendedState \n    }, (bgResponse: ToggleCollectionResponse) => {\n      if (chrome.runtime.lastError) {\n        console.error('Error toggling collection state:', chrome.runtime.lastError.message);\n        // Revert UI if error communication with background\n        updateStatus(!intendedState); \n      } else if (bgResponse && bgResponse.success && typeof bgResponse.isCollecting === 'boolean') {\n        console.log('Collection state successfully updated by background to:', bgResponse.isCollecting);\n        // Ensure UI matches the confirmed state from background, in case it differs from optimistic update\n        updateStatus(bgResponse.isCollecting);\n      } else {\n          console.error('Background failed to confirm toggle or invalid response:', bgResponse);\n          updateStatus(!intendedState); // Revert UI\n      }\n    });\n  });\n  \n  clearButton.addEventListener('click', clearEvents);\n  \n  checkServerStatus();\n  fetchEvents();\n  fetchMacros();\n  setInterval(fetchEvents, 5000);\n  setInterval(fetchMacros, 10000); // Refresh macros every 10 seconds\n});\n\n// Make functions available globally for onclick handlers\n(window as any).approveMacro = approveMacro;\n(window as any).rejectMacro = rejectMacro;\n"],"names":["serverStatus","updateStatus","collecting","statusEl","document","getElementById","toggleButton","textContent","className","async","checkServerStatus","serverStatusEl","fetch","ok","Error","error","console","fetchEvents","eventsDiv","response","status","text","data","json","innerHTML","events","Array","isArray","length","forEach","event","eventDiv","createElement","timestamp","event_type","Date","toLocaleTimeString","url","firstChild","insertBefore","addEvent","message","clearEvents","method","log","alert","fetchMacros","macroListDiv","macros","filter","macro","map","id","title","description","join","addEventListener","clearButton","statusDiv","body","chrome","runtime","sendMessage","type","lastError","isCollecting","intendedState","enabled","bgResponse","success","setInterval","window","approveMacro","macroId","rejectMacro"],"sourceRoot":""}