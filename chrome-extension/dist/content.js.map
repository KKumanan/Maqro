{"version":3,"file":"content.js","mappings":"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","sources":["webpack://macro-engine-activity-tracker/./src/types.ts","webpack://macro-engine-activity-tracker/./src/content.ts"],"sourcesContent":["export enum EventType {\n  PAGE_VIEW = 'page_view',\n  SCROLL = 'scroll',\n  CLICK = 'click',\n  FOCUS = 'focus'\n}\n\nexport interface BaseEvent {\n  event_type: EventType;\n  url: string;\n  timestamp: string;\n}\n\nexport interface PageViewEvent extends BaseEvent {\n  event_type: EventType.PAGE_VIEW;\n  title: string;\n  duration: number;\n}\n\nexport interface ScrollEvent extends BaseEvent {\n  event_type: EventType.SCROLL;\n  scrollY: number;\n}\n\nexport interface ClickEvent extends BaseEvent {\n  event_type: EventType.CLICK;\n  selector: string;\n  x: number;\n  y: number;\n}\n\nexport interface FocusEvent extends BaseEvent {\n  event_type: EventType.FOCUS;\n  state: 'focus' | 'blur';\n}\n\nexport type UserEvent = \n  | PageViewEvent \n  | ScrollEvent \n  | ClickEvent \n  | FocusEvent;\n\n// Enhanced message types with better type safety\nexport type Message = \n  | { type: 'USER_EVENT'; event: UserEvent }\n  | { type: 'TOGGLE_COLLECTION'; enabled: boolean }\n  | { type: 'GET_OPERATIONAL_STATE' }\n  | { type: 'HEALTH_CHECK' };\n\n// Statistics interface for monitoring extension performance\nexport interface ExtensionStats {\n  totalEventsSent: number;\n  totalEventsDropped: number;\n  sendFailureCount: number;\n  connectionFailures?: number;\n}\n\n// Response interfaces for better type safety\nexport interface HealthCheckResponse {\n  success: boolean;\n  isAlive: boolean;\n}\n\nexport interface OperationalStateResponse {\n  success: boolean;\n  isCollecting: boolean;\n  stats: ExtensionStats;\n}\n\nexport interface ToggleCollectionResponse {\n  success: boolean;\n  isCollecting: boolean;\n}\n\n// Global window extension for content script guard\ndeclare global {\n  interface Window {\n    maqroContentScriptLoaded?: boolean;\n  }\n}\n\n// Macro related types\nexport interface Macro {\n  id: string;\n  title: string;\n  description: string;\n  pattern: UserEvent[];\n  status: 'pending' | 'approved' | 'rejected';\n}\n\nexport interface MacroResponse {\n  success: boolean;\n  macros: Macro[];\n}","import { UserEvent, EventType, ClickEvent, ScrollEvent, FocusEvent, PageViewEvent, Message } from './types';\n\n\n// ==================== INITIALIZATION GUARD ====================\n\n// Prevent multiple script injections\nif (window.maqroContentScriptLoaded) {\n  throw new Error('Maqro content script already loaded');\n}\nwindow.maqroContentScriptLoaded = true;\n\n// ==================== CONFIGURATION ====================\n\nconst PERFORMANCE_CONFIG = {\n  // Increased throttling to reduce performance impact\n  scrollThrottleMs: 500, // Reduced from 100ms\n  resizeThrottleMs: 1000,\n  \n  // Sampling rates to reduce data volume\n  scrollSampleRate: 0.1, // Only capture 10% of scroll events\n  clickSampleRate: 1.0,   // Capture all clicks\n  \n  // Event batching\n  localBatchSize: 10, // Batch events locally before sending\n  maxRetries: 3,\n  retryDelay: 1000,\n  \n  // Performance monitoring\n  enablePerformanceLogging: false,\n  \n  // Context validation\n  contextCheckInterval: 5000, // Check context every 5 seconds\n  initializationTimeout: 10000, // Wait max 10 seconds for initialization\n} as const;\n\n// ==================== STATE MANAGEMENT ====================\n\ninterface ContentState {\n  isCollecting: boolean;\n  isHealthy: boolean;\n  isInitialized: boolean;\n  pageLoadTime: number;\n  lastScrollTime: number;\n  eventsSent: number;\n  eventsDropped: number;\n  connectionFailures: number;\n  localEventQueue: UserEvent[];\n  lastContextCheck: number;\n}\n\nconst state: ContentState = {\n  isCollecting: true,\n  isHealthy: false,\n  isInitialized: false,\n  pageLoadTime: Date.now(),\n  lastScrollTime: 0,\n  eventsSent: 0,\n  eventsDropped: 0,\n  connectionFailures: 0,\n  localEventQueue: [],\n  lastContextCheck: 0,\n};\n\n// ==================== UTILITY FUNCTIONS ====================\n\n/**\n * Enhanced logging with performance mode\n */\nfunction log(level: 'info' | 'warn' | 'error', message: string, ...args: any[]) {\n  if (level === 'error' || PERFORMANCE_CONFIG.enablePerformanceLogging) {\n    console[level]('Maqro:', message, ...args);\n  }\n}\n\n/**\n * Check if extension context is valid\n */\nfunction isContextValid(): boolean {\n  try {\n    return !!(chrome?.runtime?.id);\n  } catch (error) {\n    return false;\n  }\n}\n\n/**\n * Sampling function to reduce event volume\n */\nfunction shouldSampleEvent(eventType: EventType): boolean {\n  switch (eventType) {\n    case EventType.SCROLL:\n      return Math.random() < PERFORMANCE_CONFIG.scrollSampleRate;\n    case EventType.CLICK:\n      return Math.random() < PERFORMANCE_CONFIG.clickSampleRate;\n    default:\n      return true;\n  }\n}\n\n/**\n * Optimized element selector with caching\n */\nconst selectorCache = new WeakMap<Element, string>();\n\nfunction getElementSelector(element: Element): string {\n  // Check cache first\n  if (selectorCache.has(element)) {\n    return selectorCache.get(element)!;\n  }\n  \n  let selector: string;\n  \n  // Priority order for selector generation\n  if (element.id) {\n    selector = `#${element.id}`;\n  } else if (element.classList.length > 0) {\n    // Limit to first 3 classes to avoid overly long selectors\n    const classes = Array.from(element.classList).slice(0, 3);\n    selector = `.${classes.join('.')}`;\n  } else if (element.getAttribute('data-testid')) {\n    selector = `[data-testid=\"${element.getAttribute('data-testid')}\"]`;\n  } else if (element.getAttribute('href')) {\n    const href = element.getAttribute('href')!;\n    selector = `[href*=\"${href.substring(0, 20)}\"]`; // Limit href length\n  } else {\n    selector = element.tagName.toLowerCase();\n  }\n  \n  // Cache the result\n  selectorCache.set(element, selector);\n  return selector;\n}\n\n// ==================== EVENT HANDLING ====================\n\n/**\n * Enhanced event sending with local queueing and batching\n */\nfunction queueEvent(event: UserEvent): void {\n  // Enhanced validation before queueing\n  if (!state.isInitialized || !state.isCollecting || !state.isHealthy) {\n    state.eventsDropped++;\n    if (PERFORMANCE_CONFIG.enablePerformanceLogging) {\n      log('warn', `Event dropped - initialized: ${state.isInitialized}, collecting: ${state.isCollecting}, healthy: ${state.isHealthy}`);\n    }\n    return;\n  }\n  \n  // Quick context check before queueing\n  if (!isContextValid()) {\n    state.isHealthy = false;\n    state.eventsDropped++;\n    log('warn', 'Context invalid, dropping event');\n    return;\n  }\n  \n  // Add to local queue\n  state.localEventQueue.push(event);\n  \n  // Send batch when queue is full\n  if (state.localEventQueue.length >= PERFORMANCE_CONFIG.localBatchSize) {\n    flushEventQueue();\n  }\n}\n\n/**\n * Flush local event queue to background script\n */\nfunction flushEventQueue(): void {\n  if (state.localEventQueue.length === 0 || !state.isHealthy || !state.isInitialized) {\n    return;\n  }\n  \n  const eventsToSend = [...state.localEventQueue];\n  state.localEventQueue = [];\n  \n  sendEventsWithRetry(eventsToSend);\n}\n\n/**\n * Send events with retry logic and enhanced error handling\n */\nasync function sendEventsWithRetry(events: UserEvent[], retryCount = 0): Promise<void> {\n  // Enhanced context validation\n  if (!isContextValid()) {\n    log('warn', 'Extension context invalidated, dropping events');\n    state.eventsDropped += events.length;\n    state.isHealthy = false;\n    state.isInitialized = false;\n    return;\n  }\n  \n  try {\n    // Send events one by one with individual error handling\n    for (const event of events) {\n      await sendSingleEvent(event);\n    }\n    \n    state.eventsSent += events.length;\n    state.connectionFailures = 0; // Reset on success\n    \n  } catch (error: any) {\n    if (retryCount < PERFORMANCE_CONFIG.maxRetries) {\n      log('warn', `Retry ${retryCount + 1} for ${events.length} events:`, error.message);\n      \n      // Wait before retry with exponential backoff\n      setTimeout(() => {\n        sendEventsWithRetry(events, retryCount + 1);\n      }, PERFORMANCE_CONFIG.retryDelay * (retryCount + 1));\n    } else {\n      log('error', `Failed to send ${events.length} events after ${PERFORMANCE_CONFIG.maxRetries} retries`);\n      state.eventsDropped += events.length;\n    }\n  }\n}\n\n/**\n * Send a single event with enhanced error handling\n */\nfunction sendSingleEvent(event: UserEvent): Promise<void> {\n  return new Promise((resolve, reject) => {\n    // Final context check before sending\n    if (!isContextValid()) {\n      reject(new Error('Context invalidated before send'));\n      return;\n    }\n    \n    try {\n      chrome.runtime.sendMessage({ type: 'USER_EVENT', event }, (response) => {\n        if (chrome.runtime.lastError) {\n          const error = chrome.runtime.lastError.message || 'Unknown error';\n          \n          if (error.includes('Extension context invalidated') || \n              error.includes('message port closed') ||\n              error.includes('receiving end does not exist') ||\n              error.includes('Could not establish connection')) {\n            state.isHealthy = false;\n            state.isInitialized = false;\n            state.connectionFailures++;\n            reject(new Error('Connection lost: ' + error));\n          } else {\n            reject(new Error(error));\n          }\n        } else {\n          resolve();\n        }\n      });\n    } catch (error: any) {\n      reject(new Error('Send exception: ' + error.message));\n    }\n  });\n}\n\n// ==================== EVENT TRACKING ====================\n\n/**\n * Optimized page view tracking\n */\nfunction trackPageView(): void {\n  if (!state.isInitialized || !state.isHealthy) {\n    log('warn', 'Skipping page view tracking - not ready');\n    return;\n  }\n  \n  const event: PageViewEvent = {\n    event_type: EventType.PAGE_VIEW,\n    url: window.location.href,\n    title: document.title,\n    duration: 0,\n    timestamp: new Date().toISOString()\n  };\n  \n  queueEvent(event);\n  \n  // Track page duration on unload\n  const updateDuration = () => {\n    if (state.isInitialized && state.isHealthy) {\n      event.duration = Math.floor((Date.now() - state.pageLoadTime) / 1000);\n      queueEvent(event);\n      flushEventQueue(); // Ensure events are sent before page unloads\n    }\n  };\n  \n  // Use multiple unload events for better coverage\n  window.addEventListener('beforeunload', updateDuration);\n  window.addEventListener('pagehide', updateDuration);\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'hidden') {\n      updateDuration();\n    }\n  });\n}\n\n// ==================== EVENT LISTENERS ====================\n\n// Optimized click tracking with enhanced validation\ndocument.addEventListener('click', (e: MouseEvent) => {\n  // Early validation to prevent context errors\n  if (!state.isInitialized || !state.isHealthy || !state.isCollecting) {\n    return;\n  }\n  \n  if (!shouldSampleEvent(EventType.CLICK)) return;\n  \n  // Quick context check before processing\n  if (!isContextValid()) {\n    state.isHealthy = false;\n    return;\n  }\n  \n  const target = e.target as Element;\n  const event: ClickEvent = {\n    event_type: EventType.CLICK,\n    url: window.location.href,\n    selector: getElementSelector(target),\n    x: e.clientX,\n    y: e.clientY,\n    timestamp: new Date().toISOString()\n  };\n  \n  queueEvent(event);\n}, { passive: true }); // Use passive listener for better performance\n\n// Highly optimized scroll tracking with adaptive throttling\nlet scrollTimeoutId: number | null = null;\n\ndocument.addEventListener('scroll', () => {\n  if (!state.isInitialized || !state.isHealthy || !shouldSampleEvent(EventType.SCROLL)) return;\n  \n  const now = Date.now();\n  if (now - state.lastScrollTime < PERFORMANCE_CONFIG.scrollThrottleMs) return;\n  \n  state.lastScrollTime = now;\n  \n  // Use requestAnimationFrame to avoid blocking scroll performance\n  if (scrollTimeoutId) {\n    cancelAnimationFrame(scrollTimeoutId);\n  }\n  \n  scrollTimeoutId = requestAnimationFrame(() => {\n    if (state.isInitialized && state.isHealthy && isContextValid()) {\n      const event: ScrollEvent = {\n        event_type: EventType.SCROLL,\n        url: window.location.href,\n        scrollY: window.scrollY,\n        timestamp: new Date().toISOString()\n      };\n      \n      queueEvent(event);\n    }\n  });\n}, { passive: true });\n\n// Optimized focus tracking\nwindow.addEventListener('focus', () => {\n  if (!state.isInitialized || !state.isHealthy) return;\n  \n  const event: FocusEvent = {\n    event_type: EventType.FOCUS,\n    url: window.location.href,\n    state: 'focus',\n    timestamp: new Date().toISOString()\n  };\n  \n  queueEvent(event);\n}, { passive: true });\n\nwindow.addEventListener('blur', () => {\n  if (!state.isInitialized || !state.isHealthy) return;\n  \n  const event: FocusEvent = {\n    event_type: EventType.FOCUS,\n    url: window.location.href,\n    state: 'blur',\n    timestamp: new Date().toISOString()\n  };\n  \n  queueEvent(event);\n  flushEventQueue(); // Flush on blur to ensure data isn't lost\n}, { passive: true });\n\n// ==================== MESSAGE HANDLING ====================\n\nchrome.runtime.onMessage.addListener((message: Message, sender: any, sendResponse: (response: any) => void) => {\n  if (message.type === 'TOGGLE_COLLECTION') {\n    state.isCollecting = message.enabled ?? false;\n    log('info', `Collection ${state.isCollecting ? 'enabled' : 'disabled'}`);\n    \n    if (!state.isCollecting) {\n      flushEventQueue(); // Flush remaining events when stopping\n    }\n    \n    sendResponse({ success: true });\n    return true;\n  }\n});\n\n// ==================== HEALTH MANAGEMENT ====================\n\n/**\n * Enhanced health check with recovery logic\n */\nasync function performHealthCheck(): Promise<boolean> {\n  if (!isContextValid()) {\n    state.isHealthy = false;\n    state.isInitialized = false;\n    return false;\n  }\n  \n  return new Promise((resolve) => {\n    const timeout = setTimeout(() => {\n      state.isHealthy = false;\n      resolve(false);\n    }, 5000); // 5 second timeout\n    \n    try {\n      chrome.runtime.sendMessage({ type: 'HEALTH_CHECK' }, (response) => {\n        clearTimeout(timeout);\n        \n        if (chrome.runtime.lastError) {\n          state.isHealthy = false;\n          log('warn', 'Health check failed:', chrome.runtime.lastError.message);\n          resolve(false);\n        } else {\n          state.isHealthy = true;\n          state.lastContextCheck = Date.now();\n          resolve(true);\n        }\n      });\n    } catch (error: any) {\n      clearTimeout(timeout);\n      state.isHealthy = false;\n      log('error', 'Health check exception:', error.message);\n      resolve(false);\n    }\n  });\n}\n\n/**\n * Periodic health monitoring with automatic recovery\n */\nfunction startHealthMonitoring(): void {\n  const checkInterval = 30000; // Check every 30 seconds\n  \n  const healthCheckWorker = async () => {\n    // Skip if recently checked\n    if (Date.now() - state.lastContextCheck < PERFORMANCE_CONFIG.contextCheckInterval) {\n      return;\n    }\n    \n    if (!state.isHealthy && state.connectionFailures > 2) {\n      log('info', 'Attempting health check recovery...');\n      \n      const isHealthy = await performHealthCheck();\n      if (isHealthy) {\n        log('info', 'Health check recovery successful');\n        state.connectionFailures = 0;\n        state.isInitialized = true;\n      }\n    } else {\n      // Periodic validation even when healthy\n      await performHealthCheck();\n    }\n  };\n  \n  setInterval(healthCheckWorker, checkInterval);\n  \n  // Also check on visibility change\n  document.addEventListener('visibilitychange', () => {\n    if (document.visibilityState === 'visible') {\n      setTimeout(healthCheckWorker, 1000); // Delay to allow context to stabilize\n    }\n  });\n}\n\n// ==================== INITIALIZATION ====================\n\n/**\n * Initialize content script with robust startup\n */\nasync function initializeContentScript(): Promise<void> {\n  log('info', 'Maqro content script initializing...');\n  \n  // Wait a moment to ensure extension context is stable\n  await new Promise(resolve => setTimeout(resolve, 100));\n  \n  // Perform initial health check with timeout\n  const initTimeout = setTimeout(() => {\n    if (!state.isInitialized) {\n      log('error', 'Initialization timeout - running in degraded mode');\n      state.isHealthy = false;\n      state.isInitialized = false;\n    }\n  }, PERFORMANCE_CONFIG.initializationTimeout);\n  \n  const isHealthy = await performHealthCheck();\n  \n  if (isHealthy) {\n    state.isInitialized = true;\n    clearTimeout(initTimeout);\n    \n    // Start tracking immediately\n    trackPageView();\n    log('info', 'Content script initialized successfully');\n  } else {\n    // Retry initialization after delay\n    log('warn', 'Initial health check failed, retrying in 2 seconds...');\n    \n    setTimeout(async () => {\n      const retryHealthy = await performHealthCheck();\n      if (retryHealthy) {\n        state.isInitialized = true;\n        clearTimeout(initTimeout);\n        trackPageView();\n        log('info', 'Content script initialized on retry');\n      } else {\n        clearTimeout(initTimeout);\n        log('error', 'Content script initialization failed - running in degraded mode');\n        state.isInitialized = false;\n        state.isHealthy = false;\n      }\n    }, 2000);\n  }\n  \n  // Start health monitoring\n  startHealthMonitoring();\n  \n  // Flush any remaining events periodically\n  setInterval(() => {\n    if (state.localEventQueue.length > 0 && state.isHealthy && state.isInitialized) {\n      flushEventQueue();\n    }\n  }, 10000); // Every 10 seconds\n}\n\n// ==================== STARTUP ====================\n\n// Initialize when DOM is ready\nif (document.readyState === 'loading') {\n  document.addEventListener('DOMContentLoaded', initializeContentScript);\n} else {\n  initializeContentScript();\n}\n\n// Handle page unload to flush remaining events\nwindow.addEventListener('beforeunload', () => {\n  if (state.isHealthy && state.isInitialized) {\n    flushEventQueue();\n  }\n});\n\n// Cleanup on page unload\nwindow.addEventListener('beforeunload', () => {\n  window.maqroContentScriptLoaded = false;\n});\n"],"names":["EventType","window","maqroContentScriptLoaded","Error","state","isCollecting","isHealthy","isInitialized","pageLoadTime","Date","now","lastScrollTime","eventsSent","eventsDropped","connectionFailures","localEventQueue","lastContextCheck","log","level","message","args","console","isContextValid","chrome","runtime","id","error","shouldSampleEvent","eventType","SCROLL","Math","random","CLICK","selectorCache","WeakMap","getElementSelector","element","has","get","selector","classList","length","Array","from","slice","join","getAttribute","substring","tagName","toLowerCase","set","queueEvent","event","push","flushEventQueue","eventsToSend","sendEventsWithRetry","async","events","retryCount","sendSingleEvent","setTimeout","Promise","resolve","reject","sendMessage","type","response","lastError","includes","trackPageView","event_type","PAGE_VIEW","url","location","href","title","document","duration","timestamp","toISOString","updateDuration","floor","addEventListener","visibilityState","e","target","x","clientX","y","clientY","passive","scrollTimeoutId","performHealthCheck","timeout","clearTimeout","initializeContentScript","initTimeout","healthCheckWorker","setInterval","startHealthMonitoring","cancelAnimationFrame","requestAnimationFrame","scrollY","FOCUS","onMessage","addListener","sender","sendResponse","enabled","success","readyState"],"sourceRoot":""}